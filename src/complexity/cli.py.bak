#!/usr/bin/env python3
"""
Command-Line Interface (CLI) for Complexity

This CLI provides command-line access to search, database operations, and graph traversal
functionality from the Complexity library. It serves as a unified entry point for interacting
with various components of the system.

**Prerequisites:**

Ensure the following environment variables are set before executing commands:
- `ARANGO_HOST`: URL of the ArangoDB instance (e.g., "http://localhost:8529").
- `ARANGO_USER`: ArangoDB username (e.g., "root").
- `ARANGO_PASSWORD`: ArangoDB password.
- `ARANGO_DB_NAME`: Name of the target database (e.g., "complexity").
- API key for the configured embedding model (e.g., `OPENAI_API_KEY` if using OpenAI).
- **Optional:** `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD` for Redis caching.
- **Optional:** `LOG_LEVEL` (e.g., DEBUG, INFO, WARNING) to control verbosity.

**Invocation:**

Execute commands using the python module execution flag `-m`:
`python -m src.complexity.cli [OPTIONS] COMMAND [ARGS]...`

**Available Commands:**

--- Search Commands ---

1.  `search hybrid`: [Search] Combine keyword (BM25) and semantic search results using RRF re-ranking.
    *   WHEN TO USE: Use for the best general-purpose relevance, leveraging both keyword matching and conceptual understanding.
    *   ARGUMENTS: QUERY (Required query text).
    *   OPTIONS: --top-n/-n (int), --initial-k/-k (int), --bm25-th (float), --sim-th (float), --tags/-t (str), --json-output/-j (bool).
    *   OUTPUT: Table (default) or JSON array of results.

2.  `search semantic`: [Search] Find documents based on conceptual meaning (vector similarity).
    *   WHEN TO USE: Use when the exact keywords might be different, but the underlying meaning or concept of the query should match the documents.
    *   ARGUMENTS: QUERY (Required query text, will be embedded).
    *   OPTIONS: --threshold/-th (float), --top-n/-n (int), --tags/-t (str), --json-output/-j (bool).
    *   OUTPUT: Table (default) or JSON array of results.

3.  `search bm25`: [Search] Find documents based on keyword relevance (BM25 algorithm).
    *   WHEN TO USE: Use when you need to find documents matching specific keywords or terms present in the query text.
    *   ARGUMENTS: QUERY (Required query text).
    *   OPTIONS: --threshold/-th (float), --top-n/-n (int), --offset/-o (int), --tags/-t (str), --json-output/-j (bool).
    *   OUTPUT: Table (default) or JSON array of results.

--- Database Commands ---

4.  `db create`: [Database] Create a new document in a collection.
    *   WHEN TO USE: Use when you need to add a new document to a collection.
    *   OPTIONS: --collection/-c (str), --data-file/-f (path), --data/-d (str), --json-output/-j (bool).
    *   OUTPUT: JSON metadata or success message.

5.  `db read`: [Database] Retrieve a document by its key.
    *   WHEN TO USE: Use when you need to view the contents of a specific document.
    *   ARGUMENTS: KEY (Required document _key).
    *   OPTIONS: --collection/-c (str), --json-output/-j (bool).
    *   OUTPUT: Full JSON document or "Not Found" message.

6.  `db update`: [Database] Update an existing document.
    *   WHEN TO USE: Use to modify fields in an existing document.
    *   ARGUMENTS: KEY (Required document _key).
    *   OPTIONS: --collection/-c (str), --data-file/-f (path), --data/-d (str), --json-output/-j (bool).
    *   OUTPUT: JSON metadata or success message.

7.  `db delete`: [Database] Remove a document from a collection.
    *   WHEN TO USE: Use to permanently delete a document.
    *   ARGUMENTS: KEY (Required document _key).
    *   OPTIONS: --collection/-c (str), --yes/-y (bool), --json-output/-j (bool).
    *   OUTPUT: Success/error message or JSON status.

--- Graph Commands ---

8.  `graph add-edge`: [Graph] Create a relationship between two documents.
    *   WHEN TO USE: Use to establish a connection between documents in a graph.
    *   ARGUMENTS: FROM_KEY TO_KEY (Required document keys).
    *   OPTIONS: --collection/-c (str), --edge-collection/-e (str), --type/-t (str), --attributes/-a (str), --json-output/-j (bool).
    *   OUTPUT: JSON metadata or success message.

9.  `graph delete-edge`: [Graph] Remove a relationship between documents.
    *   WHEN TO USE: Use to remove a connection between documents in a graph.
    *   ARGUMENTS: EDGE_KEY (Required edge document key).
    *   OPTIONS: --edge-collection/-e (str), --yes/-y (bool), --json-output/-j (bool).
    *   OUTPUT: Success/error message or JSON status.

10. `graph traverse`: [Graph] Explore connections in the graph starting from a document.
    *   WHEN TO USE: Use to discover connected documents and understand the graph structure.
    *   ARGUMENTS: START_KEY (Required starting document key).
    *   OPTIONS: --collection/-c (str), --graph-name/-g (str), --min-depth (int), --max-depth (int), --direction/-dir (str), --limit/-lim (int), --json-output/-j (bool).
    *   OUTPUT: JSON array of paths or human-readable summary.

**Error Handling:**

- Errors during execution will be printed to stderr.
- Detailed logs might be available depending on `LOG_LEVEL`.
- Commands typically exit with code 0 on success and 1 on failure.
- Use `--json-output` for structured error information where applicable.
"""

import typer
import json
import sys
import os
from pathlib import Path
from typing import List, Optional, Any, Dict, Union
from loguru import logger
from rich.console import Console
from rich.table import Table
from rich.json import JSON

# Initialize Typer apps for main app and subcommands
app = typer.Typer(
    name="complexity-cli",
    help=__doc__,  # Use module docstring
    add_completion=False,
    rich_markup_mode="markdown",  # Enable markdown in help text
)

# Subcommand apps
search_app = typer.Typer(name="search", help="Find documents using various search methods.")
app.add_typer(search_app, name="search")

db_app = typer.Typer(name="db", help="Database operations (create, read, update, delete).")
app.add_typer(db_app, name="db")

graph_app = typer.Typer(name="graph", help="Graph operations for relationship management.")
app.add_typer(graph_app, name="graph")

# Rich console for formatted output
console = Console()

# --- Global State / Context & Logging Setup ---
@app.callback()
def main_callback(
    log_level: str = typer.Option(
        os.environ.get("LOG_LEVEL", "INFO").upper(),
        "--log-level",
        "-l",
        help="Set logging level (DEBUG, INFO, WARNING, ERROR).",
        envvar="LOG_LEVEL",
    ),
):
    """Main callback to configure logging for the CLI."""
    # Allow standard logging levels
    log_level = log_level.upper()
    valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
    if log_level not in valid_levels:
        print(
            f"Warning: Invalid log level '{log_level}'. Defaulting to INFO.",
            file=sys.stderr,
        )
        log_level = "INFO"

    logger.remove()  # Remove default handler
    logger.add(
        sys.stderr,
        level=log_level,
        format="{time:HH:mm:ss} | {level: <7} | {message}",
        backtrace=False,
        diagnose=False,  # Keep diagnose False for production CLI
    )
    logger.debug(f"Logging initialized at {log_level} level")

# --- Database Connection Utility ---
def get_db_connection():
    """Helper to connect and get DB object, handling errors."""
    try:
        logger.debug("Attempting to connect to ArangoDB...")
        # Import here to avoid circular imports and allow app to start even if DB is unavailable
        from complexity.arangodb.arango_setup import connect_arango, ensure_database
        from complexity.arangodb.config import ARANGO_DB_NAME

        client = connect_arango()
        if not client:
            raise ConnectionError("connect_arango() returned None")
        
        logger.debug(f"Ensuring database '{ARANGO_DB_NAME}' exists...")
        db = ensure_database(client)
        if not db:
            raise ConnectionError(
                f"ensure_database() returned None for '{ARANGO_DB_NAME}'"
            )
        
        logger.debug(f"Successfully connected to database '{db.name}'.")
        return db
    except Exception as e:
        logger.error(
            f"DB connection/setup failed: {e}", exc_info=True
        )
        console.print(
            f"[bold red]Error:[/bold red] Could not connect to or setup ArangoDB ({e}). Check connection details, permissions, and ensure ArangoDB is running."
        )
        raise typer.Exit(code=1)

# --- Result Display Utility ---
def display_results(results_data: Dict[str, Any], search_type: str, score_field: Optional[str] = None):
    """Display search results in a formatted table."""
    # Validation
    if not isinstance(results_data, dict):
        logger.warning(f"display_results expected a dict, got {type(results_data)}")
        console.print("[yellow]Warning: Invalid format for search results display.[/yellow]")
        return
    
    results = results_data.get("results", [])
    total = results_data.get("total", len(results))
    offset = results_data.get("offset", 0)

    console.print(f"\n[bold blue]--- {search_type} Results (Showing {len(results)} of ~{total}) ---[/bold blue]")

    if not results:
        console.print("[yellow]No relevant documents found matching the criteria.[/yellow]")
        return

    table = Table(
        show_header=True,
        header_style="bold magenta",
        expand=True,
        title=f"{search_type} Search Results",
    )
    
    # Configure table columns
    table.add_column("#", style="dim", width=3, no_wrap=True, justify="right")
    table.add_column(f"Score" if score_field else "-", justify="right", width=8)
    table.add_column("Key", style="cyan", no_wrap=True, width=38)
    table.add_column("Content Preview", style="green", overflow="fold", min_width=30)
    table.add_column("Tags", style="yellow", overflow="fold", min_width=15)

    # Add rows for each result
    for i, result_item in enumerate(results, start=1):
        if not isinstance(result_item, dict):
            continue
        
        score_val = result_item.get(score_field, 0.0) if score_field else None
        doc = result_item.get("doc", result_item if "_key" in result_item else {})
        
        if not doc:
            continue
        
        key = doc.get("_key", "N/A")
        # Look for content in different possible fields
        content = doc.get("content", doc.get("problem", doc.get("text", "N/A")))
        content_preview = str(content).split("\n")[0] if content else "N/A"
        tags = ", ".join(doc.get("tags", []))
        
        # Add row to table
        table.add_row(
            str(offset + i),
            f"{score_val:.4f}" if score_val is not None else "-",
            key,
            content_preview,
            tags,
        )
    
    # Display the table
    console.print(table)
    
    # Show pagination info if relevant
    if total > (offset + len(results)):
        console.print(
            f"[dim]Showing results {offset + 1}-{offset + len(results)} of {total}. Use --offset for more (if applicable).[/dim]"
        )
    elif total > 0 and total <= len(results) and offset == 0:
        console.print(f"[dim]Showing all {total} results found.[/dim]")

# --- Search Commands ---

@search_app.command("hybrid")
def search_hybrid(
    query: str = typer.Argument(..., help="The search query text."),
    top_n: int = typer.Option(
        5, "--top-n", "-n", help="Final number of ranked results.", min=1
    ),
    initial_k: int = typer.Option(
        20,
        "--initial-k",
        "-k",
        help="Number of candidates from BM25/Semantic before RRF.",
        min=1,
    ),
    bm25_threshold: float = typer.Option(
        0.01, "--bm25-th", help="BM25 candidate retrieval score threshold.", min=0.0
    ),
    sim_threshold: float = typer.Option(
        0.70,
        "--sim-th",
        help="Similarity candidate retrieval score threshold.",
        min=0.0,
        max=1.0,
    ),
    tags: Optional[str] = typer.Option(
        None,
        "--tags",
        "-t",
        help='Comma-separated list of tags to filter by (e.g., "tag1,tag2").',
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output results as JSON array."
    ),
):
    """
    Combine keyword (BM25) and semantic search results using RRF re-ranking.

    *WHEN TO USE:* Use for the best general-purpose relevance, leveraging both
    keyword matching and conceptual understanding. Often provides more robust
    results than either method alone.

    *HOW TO USE:* Provide the query text. Optionally adjust the number of final
    results (`top_n`), initial candidates (`initial_k`), candidate thresholds,
    or add tag filters.
    
    *EXAMPLES:*
    
    - Basic hybrid search for "machine learning recommendation systems":
      ```
      search hybrid "machine learning recommendation systems"
      ```
      
    - Get more results with custom BM25 threshold:
      ```
      search hybrid "secure APIs" --top-n 10 --bm25-th 0.05
      ```
      
    - More semantic-focused search with higher similarity threshold:
      ```
      search hybrid "cloud-native architecture" --sim-th 0.85
      ```
      
    - Filter results by tags:
      ```
      search hybrid "authentication" --tags security,oauth --initial-k 30
      ```
      
    - Get JSON output for programmatic use:
      ```
      search hybrid "data validation" --json-output
      ```
    """
    logger.info(f"CLI: Performing Hybrid search for '{query}'")
    
    try:
        # Get database connection
        db = get_db_connection()
        
        # Process tags if provided
        tag_list = [tag.strip() for tag in tags.split(",")] if tags else None
        
        # Import hybrid search function
        from complexity.arangodb.search_api.hybrid_search import hybrid_search
        
        # Execute search
        results_data = hybrid_search(
            db, query, top_n, initial_k, bm25_threshold, sim_threshold, tag_list
        )
        
        # Output results
        if json_output:
            print(json.dumps(results_data.get("results", []), indent=2))
        else:
            display_results(results_data, "Hybrid (RRF)", "rrf_score")
    
    except Exception as e:
        logger.error(f"Hybrid search failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during Hybrid search:[/bold red] {e}")
        raise typer.Exit(code=1)

@search_app.command("semantic")
def search_semantic(
    query: str = typer.Argument(..., help="The search query text (will be embedded)."),
    threshold: float = typer.Option(
        0.75,
        "--threshold",
        "-th",
        help="Minimum similarity score (0.0-1.0).",
        min=0.0,
        max=1.0,
    ),
    top_n: int = typer.Option(
        5, "--top-n", "-n", help="Number of results to return.", min=1
    ),
    tags: Optional[str] = typer.Option(
        None,
        "--tags",
        "-t",
        help='Comma-separated list of tags to filter by (e.g., "tag1,tag2").',
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output results as JSON array."
    ),
):
    """
    Find documents based on conceptual meaning (vector similarity).

    *WHEN TO USE:* Use when the exact keywords might be different, but the underlying
    meaning or concept of the query should match the documents. Good for finding
    semantically related content. Requires embedding generation.

    *HOW TO USE:* Provide the query text. Optionally refine with similarity
    threshold, result count, or tag filtering.
    
    *EXAMPLES:*
    
    - Basic semantic search for conceptually related documents:
      ```
      search semantic "benefits of microservice architecture"
      ```
      
    - Higher similarity threshold for stricter matching:
      ```
      search semantic "authentication versus authorization" --threshold 0.85
      ```
      
    - Get more results:
      ```
      search semantic "strategies for scaling distributed systems" --top-n 15
      ```
      
    - Filter by tags:
      ```
      search semantic "improving performance" --tags optimization,patterns
      ```
      
    - Get JSON output:
      ```
      search semantic "handling exceptions" --json-output
      ```
    """
    logger.info(f"CLI: Performing Semantic search for '{query}'")
    
    try:
        # Get database connection
        db = get_db_connection()
        
        # Process tags if provided
        tag_list = [tag.strip() for tag in tags.split(",")] if tags else None
        
        # Import required modules
        from complexity.arangodb.embedding_utils import get_embedding
        from complexity.arangodb.search_api.semantic_search import semantic_search
        
        # Generate embedding
        logger.debug("Generating query embedding...")
        query_embedding = get_embedding(query)
        if not query_embedding:
            console.print(
                "[bold red]Error:[/bold red] Failed to generate embedding for the query (returned empty/None). Check API key and model."
            )
            raise typer.Exit(code=1)
        logger.debug(f"Query embedding generated ({len(query_embedding)} dims).")
        
        # Execute search
        results_data = semantic_search(db, query_embedding, top_n, threshold, tag_list)
        
        # Output results
        if json_output:
            print(json.dumps(results_data.get("results", []), indent=2))
        else:
            display_results(results_data, "Semantic", "similarity_score")
    
    except Exception as e:
        logger.error(f"Semantic search failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during Semantic search:[/bold red] {e}")
        raise typer.Exit(code=1)

@search_app.command("bm25")
def search_bm25(
    query: str = typer.Argument(..., help="The search query text."),
    threshold: float = typer.Option(
        0.1, "--threshold", "-th", help="Minimum BM25 score.", min=0.0
    ),
    top_n: int = typer.Option(
        5, "--top-n", "-n", help="Number of results to return.", min=1
    ),
    offset: int = typer.Option(
        0, "--offset", "-o", help="Offset for pagination.", min=0
    ),
    tags: Optional[str] = typer.Option(
        None,
        "--tags",
        "-t",
        help='Comma-separated list of tags to filter by (e.g., "tag1,tag2").',
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output results as JSON array."
    ),
):
    """
    Find documents based on keyword relevance (BM25 algorithm).

    *WHEN TO USE:* Use when you need to find documents matching specific keywords
    or terms present in the query text. Good for lexical matching.

    *HOW TO USE:* Provide the query text. Optionally refine with score threshold,
    result count, pagination offset, or tag filtering.
    
    *EXAMPLES:*
    
    - Basic BM25 search for exact keyword matching:
      ```
      search bm25 "Docker container networking"
      ```
      
    - Lower threshold for more inclusive results:
      ```
      search bm25 "error handling" --threshold 0.05
      ```
      
    - Get more results:
      ```
      search bm25 "API design" --top-n 15
      ```
      
    - Paginate through results:
      ```
      search bm25 "database schema" --offset 10 --top-n 10
      ```
      
    - Filter by tags:
      ```
      search bm25 "caching strategies" --tags performance,optimization
      ```
      
    - Get JSON output:
      ```
      search bm25 "HTTP status codes" --json-output
      ```
    """
    logger.info(f"CLI: Performing BM25 search for '{query}'")
    
    try:
        # Get database connection
        db = get_db_connection()
        
        # Process tags if provided
        tag_list = [tag.strip() for tag in tags.split(",")] if tags else None
        
        # Import bm25 search function
        from complexity.arangodb.search_api.bm25_search import bm25_search
        
        # Execute search
        results_data = bm25_search(
            db=db,
            query_text=query,
            min_score=threshold,
            top_n=top_n,
            offset=offset,
            tag_list=tag_list
        )
        
        # Output results
        if json_output:
            print(json.dumps(results_data.get("results", []), indent=2))
        else:
            display_results(results_data, "BM25", "bm25_score")
    
    except Exception as e:
        logger.error(f"BM25 search failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during BM25 search:[/bold red] {e}")
        raise typer.Exit(code=1)

@search_app.command("tag")
def search_tag(
    tags: str = typer.Argument(..., help="Comma-separated list of tags to search for."),
    require_all_tags: bool = typer.Option(
        False, "--require-all", "-a", help="Whether all tags must be present (AND logic) instead of any tag (OR logic)."
    ),
    top_n: int = typer.Option(
        5, "--top-n", "-n", help="Number of results to return.", min=1
    ),
    offset: int = typer.Option(
        0, "--offset", "-o", help="Offset for pagination.", min=0
    ),
    filter_expr: Optional[str] = typer.Option(
        None, "--filter", "-f", help="Additional AQL filter expression to apply."
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output results as JSON array."
    ),
):
    """
    Search for documents by tag metadata.

    *WHEN TO USE:* Use when you want to find documents based on metadata tags
    rather than content. Perfect for filtering by categories, sources, or other
    attributes.

    *HOW TO USE:* Provide a comma-separated list of tags to search for. Use
    --require-all to find documents that have ALL the specified tags instead
    of documents with ANY of the tags.
    
    *EXAMPLES:*
    
    - Find documents tagged with either 'python' or 'javascript':
      ```
      search tag python,javascript
      ```
      
    - Find documents that have BOTH 'error' AND 'database' tags:
      ```
      search tag error,database --require-all
      ```
      
    - Get top 10 documents with the 'tutorial' tag:
      ```
      search tag tutorial --top-n 10
      ```
      
    - Output tag search results as JSON:
      ```
      search tag api,documentation --json-output
      ```
    """
    logger.info(f"CLI: Performing Tag search for '{tags}'")
    
    try:
        # Get database connection
        db = get_db_connection()
        
        # Process tags
        tag_list = [tag.strip() for tag in tags.split(",")]
        
        # Import tag search function
        from complexity.arangodb.search_api.tag_search import tag_search
        
        # Execute search
        results_data = tag_search(
            db=db,
            tags=tag_list,
            require_all_tags=require_all_tags,
            limit=top_n,
            offset=offset,
            filter_expr=filter_expr,
            output_format="json" if json_output else "table"
        )
        
        # Output results
        if json_output:
            print(json.dumps(results_data.get("results", []), indent=2))
        else:
            display_results(results_data, "Tag Search", "tag_match_score")
    
    except Exception as e:
        logger.error(f"Tag search failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during Tag search:[/bold red] {e}")
        raise typer.Exit(code=1)

@search_app.command("keyword")
def search_keyword(
    query: str = typer.Argument(..., help="The search term to look for."),
    similarity_threshold: float = typer.Option(
        97.0, "--threshold", "-th", help="Minimum similarity threshold (0-100) for fuzzy matching.", min=0.0, max=100.0
    ),
    top_n: int = typer.Option(
        5, "--top-n", "-n", help="Number of results to return.", min=1
    ),
    tags: Optional[str] = typer.Option(
        None,
        "--tags",
        "-t",
        help='Comma-separated list of tags to filter by (e.g., "tag1,tag2").',
    ),
    fields: Optional[str] = typer.Option(
        None,
        "--fields",
        "-f",
        help='Comma-separated list of fields to search in (e.g., "problem,solution").',
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output results as JSON array."
    ),
):
    """
    Find documents by keywords with fuzzy matching capabilities.

    *WHEN TO USE:* Use for flexible keyword search that can handle typos,
    slight variations, and misspellings. Good for finding terms when you
    know approximately what you're looking for.

    *HOW TO USE:* Provide a search term. Adjust the similarity threshold
    to control how strict the matching should be (higher = stricter).
    Specify fields to search within if needed.
    
    *EXAMPLES:*
    
    - Basic keyword search for "python error handling":
      ```
      search keyword "python error handling"
      ```
      
    - Search with a more lenient similarity threshold:
      ```
      search keyword "statistic" --threshold 85.0
      ```
      
    - Search only in specific fields:
      ```
      search keyword "database connection" --fields problem,solution,context
      ```
      
    - Combine with tag filtering:
      ```
      search keyword "authentication" --tags security,api --top-n 10
      ```
      
    - Get JSON output for programmatic use:
      ```
      search keyword "configuration" --json-output
      ```
    """
    logger.info(f"CLI: Performing Keyword search for '{query}'")
    
    try:
        # Get database connection
        db = get_db_connection()
        
        # Process tags if provided
        tag_list = [tag.strip() for tag in tags.split(",")] if tags else None
        
        # Process fields to search if provided
        fields_to_search = [field.strip() for field in fields.split(",")] if fields else None
        
        # Import keyword search function
        from complexity.arangodb.search_api.keyword_search import search_keyword
        
        # Execute search
        results_data = search_keyword(
            db=db,
            search_term=query,
            similarity_threshold=similarity_threshold,
            top_n=top_n,
            tags=tag_list,
            fields_to_search=fields_to_search,
            output_format="json" if json_output else "table"
        )
        
        # Output results
        if json_output:
            print(json.dumps(results_data.get("results", []), indent=2))
        else:
            display_results(results_data, "Keyword", "keyword_score")
    
    except Exception as e:
        logger.error(f"Keyword search failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during Keyword search:[/bold red] {e}")
        raise typer.Exit(code=1)

# --- Database Commands ---

@db_app.command("create")
def db_create(
    collection: str = typer.Option(
        ..., "--collection", "-c", help="Name of the collection to add document to."
    ),
    data: Optional[str] = typer.Option(
        None, "--data", "-d", help="Document data as JSON string."
    ),
    data_file: Optional[Path] = typer.Option(
        None, "--data-file", "-f", help="Path to JSON file containing document data.",
        exists=True, file_okay=True, dir_okay=False, readable=True,
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output metadata as JSON on success."
    ),
):
    """
    Create a new document in a collection.

    *WHEN TO USE:* Use when you need to add a new document to a collection.

    *HOW TO USE:* Provide the collection name and document data either as a JSON string
    or by referencing a JSON file.
    """
    logger.info(f"CLI: Creating document in collection '{collection}'")
    
    # Input validation: Ensure exactly one data source
    if not data and not data_file:
        console.print(
            "[bold red]Error:[/bold red] Either --data (JSON string) or --data-file (path to JSON file) must be provided."
        )
        raise typer.Exit(code=1)
    if data and data_file:
        console.print(
            "[bold red]Error:[/bold red] Provide either --data or --data-file, not both."
        )
        raise typer.Exit(code=1)
    
    # Load document data
    document_data = None
    source_info = ""
    
    try:
        if data_file:
            source_info = f"file '{data_file}'"
            logger.debug(f"Loading document data from file: {data_file}")
            with open(data_file, "r") as f:
                document_data = json.load(f)
        elif data:
            source_info = "string --data"
            document_data = json.loads(data)
            logger.debug("Loaded document data from string")
        
        # Validate document data
        if not isinstance(document_data, dict):
            raise ValueError("Provided data must be a JSON object (dictionary).")
    
    except json.JSONDecodeError as e:
        console.print(
            f"[bold red]Error:[/bold red] Invalid JSON provided via {source_info}: {e}"
        )
        raise typer.Exit(code=1)
    except ValueError as e:
        console.print(f"[bold red]Error:[/bold red] {e}")
        raise typer.Exit(code=1)
    except Exception as e:
        console.print(
            f"[bold red]Error reading/parsing data from {source_info}:[/bold red] {e}"
        )
        raise typer.Exit(code=1)
    
    # Get database connection
    db = get_db_connection()
    
    try:
        # Import create_document function
        from complexity.arangodb.db_operations import create_document
        
        # Create document
        meta = create_document(db, collection, document_data)
        
        if meta:
            if json_output:
                print(json.dumps(meta, indent=2))
            else:
                console.print(
                    f"[green]Success:[/green] Document added to collection '{collection}'. Key: [cyan]{meta.get('_key')}[/cyan]"
                )
        else:
            console.print(
                "[bold red]Error:[/bold red] Failed to add document (check logs for details)."
            )
            raise typer.Exit(code=1)
    
    except Exception as e:
        logger.error(f"Document creation failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during create operation:[/bold red] {e}")
        raise typer.Exit(code=1)

@db_app.command("read")
def db_read(
    key: str = typer.Argument(..., help="The _key of the document to read."),
    collection: str = typer.Option(
        ..., "--collection", "-c", help="Name of the collection containing the document."
    ),
    json_output: bool = typer.Option(
        True, "--json-output", "-j", help="Output document as JSON."
    ),
):
    """
    Retrieve a document by its key.

    *WHEN TO USE:* Use when you need to view the contents of a specific document.

    *HOW TO USE:* Provide the document key and collection name.
    """
    logger.info(f"CLI: Reading document '{key}' from collection '{collection}'")
    
    # Get database connection
    db = get_db_connection()
    
    try:
        # Import get_document function
        from complexity.arangodb.db_operations import get_document
        
        # Get document
        doc = get_document(db, collection, key)
        
        if doc:
            if json_output:
                print(json.dumps(doc, indent=2))
            else:
                console.print(f"[green]Document Found:[/green] _key=[cyan]{key}[/cyan]")
                console.print(JSON(json.dumps(doc, indent=2)))
        else:
            output = {"status": "error", "message": "Not Found", "key": key, "collection": collection}
            if json_output:
                print(json.dumps(output, indent=2))
                raise typer.Exit(code=1)
            else:
                console.print(
                    f"[yellow]Not Found:[/yellow] No document with key '{key}' in collection '{collection}'."
                )
            raise typer.Exit(code=0)
    
    except Exception as e:
        logger.error(f"Document read failed: {e}", exc_info=True)
        output = {"status": "error", "message": str(e), "key": key, "collection": collection}
        if json_output:
            print(json.dumps(output, indent=2))
        else:
            console.print(f"[bold red]Error during read operation:[/bold red] {e}")
        raise typer.Exit(code=1)

@db_app.command("update")
def db_update(
    key: str = typer.Argument(..., help="The _key of the document to update."),
    collection: str = typer.Option(
        ..., "--collection", "-c", help="Name of the collection containing the document."
    ),
    data: Optional[str] = typer.Option(
        None, "--data", "-d", help="Update data as JSON string."
    ),
    data_file: Optional[Path] = typer.Option(
        None, "--data-file", "-f", help="Path to JSON file containing update data.",
        exists=True, file_okay=True, dir_okay=False, readable=True,
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output metadata as JSON on success."
    ),
):
    """
    Update an existing document.

    *WHEN TO USE:* Use to modify fields in an existing document.

    *HOW TO USE:* Provide the document key, collection name, and update data
    either as a JSON string or by referencing a JSON file.
    """
    logger.info(f"CLI: Updating document '{key}' in collection '{collection}'")
    
    # Input validation: Ensure exactly one data source
    if not data and not data_file:
        console.print(
            "[bold red]Error:[/bold red] Either --data (JSON string) or --data-file (path to JSON file) must be provided for update."
        )
        raise typer.Exit(code=1)
    if data and data_file:
        console.print(
            "[bold red]Error:[/bold red] Provide either --data or --data-file for update, not both."
        )
        raise typer.Exit(code=1)
    
    # Load update data
    update_data = None
    source_info = ""
    
    try:
        if data_file:
            source_info = f"file '{data_file}'"
            logger.debug(f"Loading update data from file: {data_file}")
            with open(data_file, "r") as f:
                update_data = json.load(f)
        elif data:
            source_info = "string --data"
            update_data = json.loads(data)
            logger.debug("Loaded update data from string")
        
        # Validate update data
        if not isinstance(update_data, dict):
            raise ValueError("Provided update data must be a JSON object (dictionary).")
        if not update_data:
            raise ValueError("Update data cannot be empty.")
    
    except json.JSONDecodeError as e:
        console.print(
            f"[bold red]Error:[/bold red] Invalid JSON provided via {source_info}: {e}"
        )
        raise typer.Exit(code=1)
    except ValueError as e:
        console.print(f"[bold red]Error:[/bold red] {e}")
        raise typer.Exit(code=1)
    except Exception as e:
        console.print(
            f"[bold red]Error reading/parsing update data from {source_info}:[/bold red] {e}"
        )
        raise typer.Exit(code=1)
    
    # Get database connection
    db = get_db_connection()
    
    try:
        # Import update_document function
        from complexity.arangodb.db_operations import update_document
        
        # Update document
        meta = update_document(db, collection, key, update_data)
        
        if meta:
            if json_output:
                print(json.dumps(meta, indent=2))
            else:
                console.print(
                    f"[green]Success:[/green] Document [cyan]{key}[/cyan] in collection '{collection}' updated successfully."
                )
        else:
            console.print(
                f"[bold red]Error:[/bold red] Failed to update document '{key}' in collection '{collection}' (check logs for details)."
            )
            raise typer.Exit(code=1)
    
    except Exception as e:
        logger.error(f"Document update failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during update operation:[/bold red] {e}")
        raise typer.Exit(code=1)

@db_app.command("delete")
def db_delete(
    key: str = typer.Argument(..., help="The _key of the document to delete."),
    collection: str = typer.Option(
        ..., "--collection", "-c", help="Name of the collection containing the document."
    ),
    yes: bool = typer.Option(
        False, "--yes", "-y", help="Confirm deletion without interactive prompt."
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output status as JSON."
    ),
):
    """
    Remove a document from a collection.

    *WHEN TO USE:* Use to permanently delete a document.

    *HOW TO USE:* Provide the document key and collection name. Use --yes to bypass
    the confirmation prompt.
    """
    logger.info(f"CLI: Deleting document '{key}' from collection '{collection}'")
    
    # Confirmation prompt if --yes not provided
    if not yes:
        confirmed = typer.confirm(
            f"Are you sure you want to permanently delete document '[cyan]{key}[/cyan]' from collection '{collection}'?",
            abort=True,
        )
    
    # Get database connection
    db = get_db_connection()
    
    try:
        # Import delete_document function
        from complexity.arangodb.db_operations import delete_document
        
        # Delete document
        success = delete_document(db, collection, key)
        
        status = {
            "key": key,
            "collection": collection,
            "deleted": success,
            "status": "success" if success else "error",
        }
        
        if success:
            if json_output:
                print(json.dumps(status, indent=2))
            else:
                console.print(
                    f"[green]Success:[/green] Document '{key}' from collection '{collection}' deleted (or already gone)."
                )
        else:
            status["message"] = "Deletion failed due to an error (check logs)."
            if json_output:
                print(json.dumps(status, indent=2))
            else:
                console.print(
                    f"[bold red]Error:[/bold red] Failed to delete document '{key}' from collection '{collection}' (check logs)."
                )
            raise typer.Exit(code=1)
    
    except Exception as e:
        logger.error(f"Document deletion failed: {e}", exc_info=True)
        status = {"key": key, "collection": collection, "deleted": False, "status": "error", "message": str(e)}
        if json_output:
            print(json.dumps(status, indent=2))
        else:
            console.print(f"[bold red]Error during delete operation:[/bold red] {e}")
        raise typer.Exit(code=1)

# --- Graph Commands ---

@graph_app.command("add-edge")
def graph_add_edge(
    from_key: str = typer.Argument(..., help="The _key of the source document."),
    to_key: str = typer.Argument(..., help="The _key of the target document."),
    collection: str = typer.Option(
        ..., "--collection", "-c", help="Name of the document collection."
    ),
    edge_collection: str = typer.Option(
        ..., "--edge-collection", "-e", help="Name of the edge collection."
    ),
    edge_type: str = typer.Option(
        ..., "--type", "-t", help="Type of the relationship."
    ),
    rationale: str = typer.Option(
        ..., "--rationale", "-r", help="Reason for linking these documents."
    ),
    attributes: Optional[str] = typer.Option(
        None, "--attributes", "-a", help="Additional edge properties as JSON string."
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output metadata as JSON on success."
    ),
):
    """
    Create a relationship between two documents.

    *WHEN TO USE:* Use to establish a connection between documents in a graph.

    *HOW TO USE:* Provide the source and target document keys, collection names,
    relationship type, and rationale for the connection.
    """
    logger.info(f"CLI: Creating edge from '{from_key}' to '{to_key}' in collection '{edge_collection}'")
    
    # Parse additional attributes if provided
    attr_dict = None
    if attributes:
        try:
            attr_dict = json.loads(attributes)
            if not isinstance(attr_dict, dict):
                raise ValueError("Provided attributes must be a JSON object.")
        except json.JSONDecodeError as e:
            console.print(
                f"[bold red]Error:[/bold red] Invalid JSON provided for --attributes: {e}"
            )
            raise typer.Exit(code=1)
        except ValueError as e:
            console.print(f"[bold red]Error:[/bold red] {e}")
            raise typer.Exit(code=1)
    
    # Get database connection
    db = get_db_connection()
    
    try:
        # Import create_relationship function
        from complexity.arangodb.db_operations import create_relationship
        
        # Create relationship
        # Note: We're using create_relationship which creates _from and _to from collection and keys
        rel_type_upper = edge_type.upper()
        meta = create_relationship(
            db,
            from_doc_key=from_key,
            to_doc_key=to_key,
            relationship_type=rel_type_upper,
            rationale=rationale,
            attributes=attr_dict,
            from_collection=collection,
            to_collection=collection,
            edge_collection=edge_collection
        )
        
        if meta:
            if json_output:
                print(json.dumps(meta, indent=2))
            else:
                console.print(
                    f"[green]Success:[/green] Relationship added: [cyan]{from_key}[/cyan] "
                    f"-([yellow]{rel_type_upper}[/yellow], key: [cyan]{meta.get('_key')}[/cyan])-> "
                    f"[cyan]{to_key}[/cyan]"
                )
        else:
            console.print(
                "[bold red]Error:[/bold red] Failed to add relationship (check logs - keys might not exist or other DB issue)."
            )
            raise typer.Exit(code=1)
            
    except Exception as e:
        logger.error(f"Edge creation failed: {e}", exc_info=True)
        console.print(f"[bold red]Error during edge creation:[/bold red] {e}")
        raise typer.Exit(code=1)

@graph_app.command("delete-edge")
def graph_delete_edge(
    edge_key: str = typer.Argument(..., help="The _key of the edge to delete."),
    edge_collection: str = typer.Option(
        ..., "--edge-collection", "-e", help="Name of the edge collection."
    ),
    yes: bool = typer.Option(
        False, "--yes", "-y", help="Confirm deletion without interactive prompt."
    ),
    json_output: bool = typer.Option(
        False, "--json-output", "-j", help="Output status as JSON."
    ),
):
    """
    Remove a relationship between documents.

    *WHEN TO USE:* Use to remove a connection between documents in a graph.

    *HOW TO USE:* Provide the edge document key and edge collection name. Use --yes
    to bypass the confirmation prompt.
    """
    logger.info(f"CLI: Deleting edge '{edge_key}' from collection '{edge_collection}'")
    
    # Confirmation prompt if --yes not provided
    if not yes:
        confirmed = typer.confirm(
            f"Are you sure you want to delete edge '[cyan]{edge_key}[/cyan]' from collection '{edge_collection}'?",
            abort=True,
        )
    
    # Get database connection
    db = get_db_connection()
    
    try:
        # Import delete_relationship_by_key function
        from complexity.arangodb.db_operations import delete_relationship_by_key
        
        # Delete edge
        success = delete_relationship_by_key(db, edge_key, edge_collection)
        
        status = {
            "edge_key": edge_key,
            "edge_collection": edge_collection,
            "deleted": success,
            "status": "success" if success else "error",
        }
        
        if success:
            if json_output:
                print(json.dumps(status, indent=2))
            else:
                console.print(
                    f"[green]Success:[/green] Edge '{edge_key}' from collection '{edge_collection}' deleted (or already gone)."
                )
        else:
            status["message"] = "Deletion failed due to an error (check logs)."
            if json_output:
                print(json.dumps(status, indent=2))
            else:
                console.print(
                    f"[bold red]Error:[/bold red] Failed to delete edge '{edge_key}' from collection '{edge_collection}'."
                )
            raise typer.Exit(code=1)
            
    except Exception as e:
        logger.error(f"Edge deletion failed: {e}", exc_info=True)
        status = {"edge_key": edge_key, "edge_collection": edge_collection, "deleted": False, "status": "error", "message": str(e)}
        if json_output:
            print(json.dumps(status, indent=2))
        else:
            console.print(f"[bold red]Error during edge deletion:[/bold red] {e}")
        raise typer.Exit(code=1)

@graph_app.command("traverse")
def graph_traverse(
    start_key: str = typer.Argument(..., help="The _key of the starting document."),
    collection: str = typer.Option(
        ..., "--collection", "-c", help="Name of the document collection."
    ),
    graph_name: str = typer.Option(
        ..., "--graph-name", "-g", help="Name of the graph to traverse."
    ),
    min_depth: int = typer.Option(
        1, "--min-depth", help="Minimum traversal depth.", min=0
    ),
    max_depth: int = typer.Option(
        1, "--max-depth", help="Maximum traversal depth.", min=0
    ),
    direction: str = typer.Option(
        "OUTBOUND", "--direction", "-dir", help="Direction: OUTBOUND, INBOUND, or ANY."
    ),
    limit: int = typer.Option(
        10, "--limit", "-lim", help="Maximum number of paths to return.", min=1
    ),
    json_output: bool = typer.Option(
        True, "--json-output", "-j", help="Output results as JSON."
    ),
):
    """
    Explore connections in the graph starting from a document.

    *WHEN TO USE:* Use to discover connected documents and understand the graph structure.

    *HOW TO USE:* Provide the starting document key, collection name, and graph name.
    Adjust traversal parameters as needed.
    """
    logger.info(f"CLI: Traversing graph '{graph_name}' from '{start_key}' in collection '{collection}'")
    
    # Validate direction input
    valid_directions = ["OUTBOUND", "INBOUND", "ANY"]
    dir_upper = direction.upper()
    if dir_upper not in valid_directions:
        console.print(
            f"[bold red]Error:[/bold red] Invalid direction '{direction}'. Must be one of: {', '.join(valid_directions)}"
        )
        raise typer.Exit(code=1)
    
    # Validate depth
    if min_depth > max_depth:
        console.print(
            f"[bold red]Error:[/bold red] min_depth ({min_depth}) cannot be greater than max_depth ({max_depth})."
        )
        raise typer.Exit(code=1)
    
    # Get database connection
    db = get_db_connection()
    
    try:
        # Import graph_traverse function
        from complexity.arangodb.search_api.graph_traverse import graph_traverse as traverse_func
        
        # Get the fully qualified start vertex ID
        start_vertex_id = f"{collection}/{start_key}"
        
        # Execute traversal
        results_data = traverse_func(
            db=db,
            start_vertex_key=start_key,  # Pass just the key, let function handle collection
            min_depth=min_depth,
            max_depth=max_depth,
            direction=dir_upper,
            limit=limit,
            start_vertex_collection=collection,
            graph_name=graph_name
        )
        
        # Handle missing results
        if results_data is None:
            logger.error(f"Graph traversal API returned None for start node {start_vertex_id}")
            console.print(
                f"[bold red]Error:[/bold red] Graph traversal failed (API returned None). Check logs."
            )
            raise typer.Exit(code=1)
        
        # Output results
        if json_output:
            print(json.dumps(results_data.get("results", []), indent=2))
        else:
            # Simple summary for human-readable output
            path_count = results_data.get("count", 0)
            if path_count > 0:
                console.print(
                    f"[green]Traversal complete.[/green] Found {path_count} paths. Use -j for detailed JSON output."
                )
            else:
                console.print("[yellow]Traversal complete. No paths found.[/yellow]")
                
    except Exception as e:
        logger.error(f"Graph traversal failed: {e}", exc_info=True)
        output = {"status": "error", "message": str(e), "start_vertex": f"{collection}/{start_key}"}
        if json_output:
            print(json.dumps(output, indent=2))
        else:
            console.print(f"[bold red]Error during graph traversal:[/bold red] {e}")
        raise typer.Exit(code=1)

# --- Initialization Command ---
@app.command("init")
def initialize_database(
    create_collections: bool = typer.Option(
        True, "--create-collections", "-c", help="Create required collections"
    ),
    create_sample_data: bool = typer.Option(
        True, "--create-sample-data", "-s", help="Create sample data for testing"
    ),
    force: bool = typer.Option(
        False, "--force", "-f", help="Force recreation of collections even if they exist"
    )
):
    """
    Initialize ArangoDB with collections and sample data for testing the CLI.
    
    *WHEN TO USE:* Use before running tests to ensure your database has the required
    structure and sample data for testing all CLI commands.
    
    *HOW TO USE:* Run with default options to create all necessary collections and
    sample data, or customize with flags.
    
    *EXAMPLES:*
    
    - Basic initialization with collections and sample data:
      ```
      init
      ```
      
    - Create only collections without sample data:
      ```
      init --no-create-sample-data
      ```
      
    - Force recreation of collections (will drop existing):
      ```
      init --force
      ```
    """
    logger.info("Initializing database for CLI testing")
    
    # Get database connection
    db = get_db_connection()
    
    # Define required collections
    required_collections = [
        "test_docs",          # For database CRUD operations
        "messages",           # For search operations
        "relationships",      # For graph operations
        "test_relationships"  # For graph tests
    ]
    
    # Create collections if requested
    if create_collections:
        for collection_name in required_collections:
            collection_exists = db.has_collection(collection_name)
            
            if collection_exists and force:
                logger.info(f"Dropping existing collection '{collection_name}'")
                db.delete_collection(collection_name)
                collection_exists = False
            
            if not collection_exists:
                is_edge = "relationship" in collection_name.lower()
                logger.info(f"Creating {'edge ' if is_edge else ''}collection '{collection_name}'")
                db.create_collection(collection_name, edge=is_edge)
                console.print(f"[green]Created {'edge ' if is_edge else ''}collection:[/green] [cyan]{collection_name}[/cyan]")
            else:
                console.print(f"[yellow]Collection already exists:[/yellow] [cyan]{collection_name}[/cyan]")
    
    # Create sample data if requested
    if create_sample_data:
        console.print("[bold cyan]Creating sample data...[/bold cyan]")
        
        # Create sample documents for search testing
        for i in range(1, 6):
            doc_key = f"python_error_{i}_{uuid.uuid4().hex[:8]}"
            
            # Check if document exists
            if db.collection("messages").has(doc_key) and not force:
                console.print(f"[yellow]Sample document already exists:[/yellow] [cyan]{doc_key}[/cyan]")
                continue
            
            # Create sample document
            doc = {
                "_key": doc_key,
                "question": f"What is Python error #{i}?",
                "answer": f"This is a sample document about Python error #{i}.",
                "tags": ["python", "error", f"error-{i}"],
                "created_at": time.time()
            }
            
            # Insert document
            db.collection("messages").insert(doc)
            console.print(f"[green]Created sample document:[/green] [cyan]{doc_key}[/cyan]")
        
        # Create sample edge
        if len(list(db.collection("messages").all())) >= 2:
            # Get first two document IDs
            doc_keys = [doc["_key"] for doc in db.collection("messages").all(limit=2)]
            
            # Create edge
            edge = {
                "_from": f"messages/{doc_keys[0]}",
                "_to": f"messages/{doc_keys[1]}",
                "type": "RELATED_TO",
                "weight": 0.8
            }
            
            # Insert edge
            db.collection("relationships").insert(edge)
            console.print(f"[green]Created sample edge:[/green] [cyan]{doc_keys[0]}[/cyan] -> [cyan]{doc_keys[1]}[/cyan]")
    
    console.print("[bold green]✓ Database initialization completed![/bold green]")

# --- Main Execution ---
if __name__ == "__main__":
    try:
        app()
    except typer.Exit as e:
        sys.exit(e.exit_code)
    except Exception as e:
        logger.critical(f"Unhandled exception during CLI execution: {e}", exc_info=True)
        console.print(
            f"[bold red]FATAL ERROR:[/bold red] An unexpected error occurred. Check logs. ({e})"
        )
        sys.exit(1)